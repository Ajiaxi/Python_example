#!/usr/bin/python3.5
#coding:utf-8

# and 和 or 的 特殊性质
#在 Python 中, and 和 or 执行布尔逻辑演算,如你所期待的一样。但是它们并
#不返回布尔值,而是返回它们实际进行比较的值之一

# #and 介绍
# >>> 'a' and 'b'
# 'b'
# >>> '' and 'b'
# ''
# >>> 'a' and 'b' and 'c'
# 'c'
'''
(1) 使用 and 时,在布尔环境中从左到右演算表达式的值。
0 、 '' 、 [] 、 () 、 {} 、 None
在布尔环境中为假;其它任何东西都为真。还好,
几乎是所有东西。默认情况下,布尔环境中的类实例为真,但是你可以在
类中定义特定的方法使得类实例的演算值为假。你将会在第 5 章 中了解到
类和这些特殊方法。如果布尔环境中的所有值都为真,那么 and 返回最后
一个值。在这个例子中, and 演算 'a' 的值为真,然后是 'b' 的演算值为真,
最终返回 'b' 。
(2) 如果布尔环境中的某个值为假,则 and 返回第一个假值。在这个例子
中, '' 是第一个假值。
(3) 所有值都为真,所以 and 返回最后一个真值, 'c'
'''

# #or 介绍
# >>> 'a' or 'b'
# 'a'
# >>> '' or 'b'
# 'b'
# >>> '' or [] or {}
# {}
# >>> def sidefx():
# ... print "in sidefx()"
# ... return 1
# >>> 'a' or sidefx()
# 'a'

'''
(1) 使用 or 时,在布尔环境中从左到右演算值,就像 and 一样。如果有一个值
为真, or 立刻返回该值。本例中, 'a' 是第一个真值。
(2) or 演算 '' 的值为假,然后演算 'b' 的值为真,于是返回 'b' 。
(3) 如果所有的值都为假, or 返回最后一个假值。 or 演算 '' 的值为假,然后演
算 [] 的值为假,依次演算 {} 的值为假,最终返回 {} 。
(4) 注意 or 在布尔环境中会一直进行表达式演算直到找到第一个真值,然后
就会忽略剩余的比较值。如果某些值具有副作用,这种特性就非常重要了。
在这里,函数 sidefx 永远都不会被调用,因为 or 演算 'a' 的值为真,所以
紧接着就立刻返回 'a' 了。
如果你是一名 C 语言黑客,肯定很熟悉 bool ? a : b 表达式,如果 bool 为真,表
达式演算值为 a ,否则为 b 。基于 Python 中 and 和 or 的工作方式,你可以完
成相同的事情
'''

# #使用 and-or 技巧
# #and-or 技巧介绍
# >>> a = "first"
# >>> b = "second"
# >>> 1 and a or b
# 'first'
# >>> 0 and a or b
# 'second'

'''
(1) 这个语法看起来类似于 C 语言中的 bool ? a : b 表达式。整个表达式从左到
右进行演算,所以先进行 and 表达式的演算。 1 and 'first' 演算值为 'first' ,
然后 'first' or 'second' 的演算值为 'first' 。
(2) 0 and 'first' 演算值为 False ,然后 0 or 'second' 演算值为 'second' 。
然而,由于这种 Python 表达式单单只是进行布尔逻辑运算,并不是语言的特
定构成,这是 and-or 技巧和 C 语言中的 bool ? a : b 语法非常重要的不同。如果
a
为假,表达式就不会按你期望的那样工作了。(你能知道我被这个问题折腾
过吗?不止一次?)
'''

# #and-or 技巧无效的场合
# >>> a = ""
# >>> b = "second"
# >>> 1 and a or b
# 'second'

'''
(1) 由于 a 是一个空字符串,在 Python 的布尔环境中空字符串被认为是假的,
1 and ''
的演算值为 '' ,最后 '' or 'second' 的演算值为 'second' 。噢!这个值
并不是你想要的。
and-or
技巧,也就是 bool and a or b 表达式,当 a 在布尔环境中的值为假时,不
会像 C 语言表达式 bool ? a : b 那样工作。
在 and-or 技巧后面真正的技巧是,确保 a 的值决不会为假。最常用的方式是使
a
成为 [a] 、 b 成为 [b] ,然后使用返回值列表的第一个元素,应该是 a 或 b 中
的某一个
'''

# #安全使 用 and-or 技巧
# >>> a = ""
# >>> b = "second"
# >>> (1 and [a] or [b])[0]
# ''
'''
(1) 由于 [a] 是一个非空列表,所以它决不会为假。即使 a 是 0 或者 '' 或者其
它假值,列表 [a] 也为真,因为它有一个元素。
到现在为止,这个技巧可能看上去问题超过了它的价值。毕竟,使用 if 语句
可以完成相同的事情,那为什么要经历这些麻烦事呢?哦,在很多情况下,
你要在两个常量值中进行选择,由于你知道 a 的值总是为真,所以你可以使
用这种较为简单的语法而且不用担心。对于使用更为复杂的安全形式,依然
有很好的理由要求这样做。例如,在 Python 语言的某些情况下 if 语句是不允
许使用的,比如在 lambda 函数中
'''