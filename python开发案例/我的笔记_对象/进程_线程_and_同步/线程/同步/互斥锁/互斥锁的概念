* 当多个线程⼏乎同时修改某⼀个共享数据的时候, 需要进⾏同步控制

* 线程同步能够保证多个线程安全访问竞争资源， 最简单的同步机制是引⼊互斥锁。

* 互斥锁为资源引⼊⼀个状态： 锁定/⾮锁定。

某个线程要更改共享数据时, 先将其锁定, 此时资源的状态为“锁定”
其他线程不能更改; 直到该线程释放资源, 将资源的状态变成“⾮锁定”
其他的线程才能再次锁定该资源.

## 互斥锁保证了每次只有⼀个线程进⾏写⼊操作, 从⽽保证了多线程情况下数据的正确性。

## threading模块中定义了Lock类， 可以⽅便的处理锁定：
    # 创建锁
    mutex = threading.Lock()
    # 锁定
    mutex.acquire([blocking])
    # 释放
    mutex.release()
    其中, 锁定⽅法acquire可以有⼀个blocking参数。
    如果设定blocking为True， 则当前线程会堵塞， 直到获取到这个锁为⽌(如果没有指定, 那么默认为True)
    如果设定blocking为False， 则当前线程不会堵塞

## 上锁解锁过程
    1. 当⼀个线程调⽤锁的acquire()⽅法获得锁时, 锁就进⼊“locked”状态.
    2. 每次只有⼀个线程可以获得锁. 如果此时另⼀个线程试图获得这个锁, 该线
        程就会变为“blocked”状态, 称为“阻塞”, 直到拥有锁的线程调⽤锁的
    3. release()⽅法释放锁之后， 锁进⼊“unlocked”状态。
    4. 线程调度程序从处于同步阻塞状态的线程中选择⼀个来获得锁， 并使得该线
    程进⼊运⾏（ running） 状态

## 总结
    锁的好处：
        确保了某段关键代码只能由⼀个线程从头到尾完整地执⾏
    锁的坏处：
        1. 阻⽌了多线程并发执⾏, 包含锁的某段代码实际上只能以单线程模式执
            ⾏, 效率就⼤⼤地下降了
        2. 由于可以存在多个锁， 不同的线程持有不同的锁， 并试图获取对⽅持有
        的锁时， 可能会造成死锁